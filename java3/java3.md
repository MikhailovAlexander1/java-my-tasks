## java3

Данная папка репозитория содержит выполненные мной задания по курсу "Технологии Java" на языке Java.

Исходный источник заданий -> [тут](https://web.archive.org/web/20230703105945/https://www.kgeorgiy.info/courses/java-advanced/homeworks.html)

Исходники тестов к заданиям -> [тут пока ничего нет]()

Тестов к этой папке пока нет, нужно подумать как их сюда подключить.

---
#### <a id="tasks-list">Список представленных в репозитории выполненных работ:</a>
- [Обход файлов](#file-browse)
- [Множество на массиве](#array-set)
- [Студенты](#students)
- [Implementor](#Implementor)
- [Итеративный параллелизм](#iterative-parallelism)
- [Параллельный запуск](#parallel-mapper)
- [Web Crawler](#web-crawler)
- [HelloUDP](#hello-udp)

---

### <a id="file-browse">Обход файлов</a>
[Вернуться к списку заданий](#tasks-list)
1. Разработайте класс ```Walk```, осуществляющий подсчет хеш-сумм файлов.
2. Формат запуска: ```java Walk <входной файл> <выходной файл>```.
3. Входной файл содержит список файлов, которые требуется обойти.
4. Выходной файл должен содержать по одной строке для каждого файла. Формат строки: ```<шестнадцатеричная хеш-сумма> <путь к файлу>```.
5. Для подсчета хеш-суммы используйте алгоритм SHA-256 (поддержка есть в стандартной библиотеке). 
6. Если при чтении файла возникают ошибки, укажите в качестве его хеш-суммы все нули. 
7. Кодировка входного и выходного файлов — UTF-8. 
8. Размеры файлов могут превышать размер оперативной памяти. 

Решение данного задания можно посмотреть [здесь](java-advanced/java-solutions/info/kgeorgiy/ja/mikhailov/walk/Walk.java) в ```Walk.java```.

<h5>Модификации</h5>

Модификации в данном курсе представлены как усложненные тесты после начала сдачи задания.

---

### <a id="array-set">Множество на массиве</a>
[Вернуться к списку заданий](#tasks-list)
1. Разработайте класс ```ArraySet```, реализующий неизменяемое упорядоченное множество.
   - Класс ```ArraySet``` должен реализовывать интерфейс ```SortedSet``` (простой вариант) или ```NavigableSet``` (сложный вариант).
   - Все операции над множествами должны производиться с максимально возможной асимптотической эффективностью.
2. При выполнении задания следует обратить внимание на:
   - Применение стандартных коллекций. 
   - Избавление от повторяющегося кода.

Решение данного задания можно посмотреть [здесь](java-advanced/java-solutions/info/kgeorgiy/ja/mikhailov/arrayset/ArraySet.java) в ```ArraySet.java```.

---

### <a id="students">Студенты</a>
[Вернуться к списку заданий](#tasks-list)
1. Разработайте класс ```StudentDB```, осуществляющий поиск по базе данных студентов. 
   - Класс ```StudentDB``` должен реализовывать интерфейс ```StudentQuery``` (простой вариант) или ```GroupQuery``` (сложный вариант). 
   - Каждый метод должен состоять из ровно одного оператора. При этом длинные операторы надо разбивать на несколько строк.
2. При выполнении задания следует обратить внимание на:
   - применение лямбда-выражений и потоков;
   - избавление от повторяющегося кода.

     Решение данного задания можно посмотреть [здесь](java-advanced/java-solutions/info/kgeorgiy/ja/mikhailov/student/StudentDB.java) в ```StudentDB.java```.

---

### <a id="implementor">Implementor</a>
[Вернуться к списку заданий](#tasks-list)
1. Реализуйте класс ```Implementor```, генерирующий реализации классов и интерфейсов. 
   - Аргумент командной строки: полное имя класса/интерфейса, для которого требуется сгенерировать реализацию. 
   - В результате работы должен быть сгенерирован java-код класса с суффиксом ```Impl```, расширяющий (реализующий) указанный класс (интерфейс). 
   - Сгенерированный класс должен компилироваться без ошибок. 
   - Сгенерированный класс не должен быть абстрактным. 
   - Методы сгенерированного класса должны игнорировать свои аргументы и возвращать значения по умолчанию.
2. В задании выделяются три варианта:
   - _Простой_ — ```Implementor``` должен уметь реализовывать только интерфейсы (но не классы). Поддержка generics не требуется.
   - _Сложный_ — ```Implementor``` должен уметь реализовывать и классы, и интерфейсы. Поддержка generics не требуется.
   - _Бонусный_ — ```Implementor``` должен уметь реализовывать generic-классы и интерфейсы. Сгенерированный код должен иметь корректные параметры типов и не порождать UncheckedWarning.

3. Создайте .jar-файл, содержащий скомпилированный ```Implementor``` и сопутствующие классы.
   - Созданный .jar-файл должен запускаться командой java -jar.
   - Запускаемый .jar-файл должен принимать те же аргументы командной строки, что и класс Implementor.
4. Модифицируйте ```Implemetor``` так, чтобы при запуске с аргументами -jar имя-класса файл.jar он генерировал .jar-файл с реализацией соответствующего класса (интерфейса).
5. Для проверки, кроме исходного кода так же должны быть представлены:
   - скрипт для создания запускаемого .jar-файла, в том числе исходный код манифеста;
   - запускаемый .jar-файл.
6. **Сложный вариант**. Решение должно быть модуляризовано.

7. Документируйте класс ```Implementor``` и сопутствующие классы с применением _Javadoc_. 
   - Должны быть документированы все классы и все члены классов, в том числе _private_.
   - Документация должна генерироваться без предупреждений.
   - Сгенерированная документация должна содержать корректные ссылки на классы стандартной библиотеки.
8. Для проверки, кроме исходного кода так же должны быть представлены:
   - скрипт для генерации документации;
   - сгенерированная документация.

Решение данного задания можно посмотреть [здесь](java-advanced/java-solutions/info/kgeorgiy/ja/mikhailov/implementor/Implementor.java) в ```Implementor.java```.

---

### <a id="iterative-parallelism">Итеративный параллелизм</a>
[Вернуться к списку заданий](#tasks-list)
1. Реализуйте класс ```IterativeParallelism```, который будет обрабатывать списки в несколько потоков.
2. В простом варианте должны быть реализованы следующие методы:
   - ```minimum(threads, list, comparator)``` — первый минимум;
   - ```maximum(threads, list, comparator)``` — первый максимум;
   - ```all(threads, list, predicate)``` — проверка, что все элементы списка, удовлетворяют предикату;
   - ```any(threads, list, predicate)``` — проверка, что существует элемент списка, удовлетворяющий предикату.
   - ```count(threads, list, predicate)``` — подсчёт числа элементов списка, удовлетворяющих предикату.
3. В сложном варианте должны быть дополнительно реализованы следующие методы:
   - ```filter(threads, list, predicate)``` — вернуть список, содержащий элементы удовлетворяющие предикату;
   - ```map(threads, list, function)``` — вернуть список, содержащий результаты применения функции;
   - ```join(threads, list)``` — конкатенация строковых представлений элементов списка.
4. Во все функции передается параметр ```threads``` — сколько потоков надо использовать при вычислении. Вы можете рассчитывать, что число потоков относительно мало.
5. Не следует рассчитывать на то, что переданные компараторы, предикаты и функции работают быстро.
6. При выполнении задания **нельзя** использовать _Concurrency Utilities_.

Решение данного задания можно посмотреть [здесь](java-advanced/java-solutions/info/kgeorgiy/ja/mikhailov/concurrent/IterativeParallelism.java) в ```IterativeParallelism.java```.

---

### <a id="parallel-mapper">Параллельный запуск</a>
[Вернуться к списку заданий](#tasks-list)
1. Напишите класс ```ParallelMapperImpl```, реализующий интерфейс ```ParallelMapper```.

```java
public interface ParallelMapper extends AutoCloseable {
    <T, R> List<R> map(
        Function<? super T, ? extends R> f,
        List<? extends T> args
    ) throws InterruptedException;

    @Override
    void close();
}
```

-
   - Метод ```map``` должен параллельно вычислять функцию f на каждом из указанных аргументов (args). 
   - Метод ```close``` должен останавливать все рабочие потоки.
   - Конструктор ```ParallelMapperImpl(int threads)``` создает threads рабочих потоков, которые могут быть использованы для распараллеливания.
   - К одному ```ParallelMapperImpl``` могут одновременно обращаться несколько клиентов.
   - Задания на исполнение должны накапливаться в очереди и обрабатываться в порядке поступления.
   - В реализации не должно быть активных ожиданий.
2. Доработайте класс ```IterativeParallelism``` так, чтобы он мог использовать ```ParallelMapper```. 
   - Добавьте конструктор ```IterativeParallelism(ParallelMapper)```.
   - Методы класса должны делить работу на threads фрагментов и исполнять их при помощи ```ParallelMapper```.
   - При наличии ```ParallelMapper``` сам ```IterativeParallelism``` новые потоки создавать не должен.
   - Должна быть возможность одновременного запуска и работы нескольких клиентов, использующих один ```ParallelMapper```.
3. При выполнении задания всё ещё нельзя использовать Concurrency Utilities.

Решение данного задания можно посмотреть [здесь](java-advanced/java-solutions/info/kgeorgiy/ja/mikhailov/concurrent/ParallelMapperImpl.java) в ```ParallelMapperImpl.java```.

---

### <a id="web-crawler">Web Crawler</a>
[Вернуться к списку заданий](#tasks-list)
1. Напишите потокобезопасный класс ```WebCrawler```, который будет рекурсивно обходить сайты. 
2. Класс ```WebCrawler``` должен иметь конструктор ```public WebCrawler(Downloader downloader, int downloaders, int extractors, int perHost)```
   - ```downloader``` позволяет скачивать страницы и извлекать из них ссылки;
   - ```downloaders``` — максимальное число одновременно загружаемых страниц;
   - ```extractors``` — максимальное число страниц, из которых одновременно извлекаются ссылки;
   - ```perHost``` — максимальное число страниц, одновременно загружаемых c одного хоста. Для определения хоста следует использовать метод getHost класса URLUtils из тестов.
3. Класс ```WebCrawler``` должен реализовывать интерфейс ```Crawler```

```java
   public interface Crawler extends AutoCloseable {
       Result download(String url, int depth);
        
       void close();
   }
```
-
  - Метод ```download``` должен рекурсивно обходить страницы, начиная с указанного URL, на указанную глубину и возвращать список загруженных страниц и файлов. Например, если глубина равна 1, то должна быть загружена только указанная страница. Если глубина равна 2, то указанная страница и те страницы и файлы, на которые она ссылается, и так далее.
  - Метод ```download``` может вызываться параллельно в нескольких потоках.
  - Загрузка и обработка страниц (извлечение ссылок) должна выполняться максимально параллельно, с учетом ограничений на число одновременно загружаемых страниц (в том числе с одного хоста) и страниц, с которых загружаются ссылки.
  - Для распараллеливания разрешается создать до ```downloaders + extractors``` вспомогательных потоков.
  - Повторно загружать и/или извлекать ссылки из одной и той же страницы в рамках одного обхода (```download```) запрещается.
  - Метод ```close``` должен завершать все вспомогательные потоки.
  
4. Для загрузки страниц должен применяться ```Downloader```, передаваемый первым аргументом конструктора.

```java
    public interface Downloader {
        public Document download(final String url) throws IOException;
    }
```
-
   - Метод ```download``` загружает документ по его адресу (URL).
   - Ссылки, возвращаемые документом, являются абсолютными и имеют схему http или https.
   - Документ позволяет получить ссылки по загруженной странице:
```java 
     public interface Document {
         List<String> extractLinks() throws IOException;
     }
```
5. Версии задания 
   - _Простая_ — не требуется учитывать ограничения на число одновременных закачек с одного хоста ```(perHost >= downloaders)```.
   - _Полная_ — требуется учитывать все ограничения.
   - _Бонусная_ — сделать параллельный обход в ширину.
6. Задание подразумевает активное использование Concurrency Utilities, в частности, в решении не должно быть «велосипедов», аналогичных/легко сводящихся к классам из Concurrency Utilities.


Решение данного задания можно посмотреть [здесь](java-advanced/java-solutions/info/kgeorgiy/ja/mikhailov/crawler/WebCrawler.java) в ```WebCrawler.java```.

---

### <a id="hello-udp">HelloUDP</a>
[Вернуться к списку заданий](#tasks-list)
1. Реализуйте клиент и сервер, взаимодействующие по UDP.
2. Класс ```HelloUDPClient``` должен отправлять запросы на сервер, принимать результаты и выводить их на консоль. 
   - Аргументы командной строки:
     1. имя или ip-адрес компьютера, на котором запущен сервер;
     2. номер порта, на который отсылать запросы;
     3. префикс запросов (строка);
     4. число параллельных потоков запросов;
     5. число запросов в каждом потоке.
   - Запросы должны одновременно отсылаться в указанном числе потоков. Каждый поток должен ожидать обработки своего запроса и выводить сам запрос и результат его обработки на консоль. Если запрос не был обработан, требуется послать его заново.
   - Запросы должны формироваться по схеме ```<префикс запросов><номер потока>_<номер запроса в потоке>```.
3. Класс ```HelloUDPServer``` должен принимать задания, отсылаемые классом ```HelloUDPClient``` и отвечать на них. 
   - Аргументы командной строки:
     1. номер порта, по которому будут приниматься запросы; 
     2. число рабочих потоков, которые будут обрабатывать запросы. 
   - Ответом на запрос должно быть ```Hello, <текст запроса>```. 
   - Несмотря на то, что текущий способ получения ответа по запросу очень прост, сервер должен быть рассчитан на ситуацию, когда этот процесс может требовать много ресурсов и времени. 
   - Если сервер не успевает обрабатывать запросы, прием запросов может быть временно приостановлен.

Решение данного задания можно посмотреть [здесь](java-advanced/java-solutions/info/kgeorgiy/ja/mikhailov/hello) в ```HelloUDPClient.java``` и ```HelloUDPServer.java```.

---