## java1

Данная папка репозитория содержит выполненные мной задания по курсу "Введение в программирование" на языке Java.

Исходный источник заданий -> [тут](https://web.archive.org/web/20220705034247/https://www.kgeorgiy.info/courses/prog-intro/homeworks.html#runme)

Исходники тестов к заданиям -> [тут](java)

---
#### <a id="tasks-list">Список представленных в репозитории выполненных работ:</a>
- [Реверс](#reverse)
- [Свой сканер](#my-own-scanner)
- [Статистика слов++](#word-statistics++)
- [Markdown to HTML](#markdown-to-html)
- [Игра m,n,k](#mnk-game)
- [Выражения](#expressions)

---

### <a id="reverse">Реверс</a>
[Вернуться к списку заданий](#tasks-list)
1. Разработайте класс Reverse, читающий числа из стандартного ввода, и выводящий их на стандартный вывод в обратном порядке.
2. В каждой строке входа содержится некоторое количество целых чисел (возможно ноль). Числа разделены пробелами. Каждое число помещается в тип int.
3. Порядок строк в выходе должен быть обратным по сравнению с порядком строк во входе. Порядок чисел в каждой строке также должен быть обратным к порядку чисел во входе.
4. Вход содержит не более 106 чисел и строк.
5. Для чтения чисел используйте класс Scanner.

Решение данного задания можно посмотреть [здесь](Reverse.java) в ```Reverse.java```.

<h5>Модификации</h5> 

(тесты для базовой реализации и модификации: [```ReverseTest.jar```](ReverseTest.jar), [```FastReverseTest.jar```](FastReverseTest.jar)):
- Abc2 ([решение](ReverseAbc2.java) представлено в классе ```ReverseAbc2.java```)
  - Во вводе и выводе используются числа, записанные буквами: нулю соответствует буква a, единице – b и так далее.
  - Класс должен иметь имя ReverseAbc2.

---

### <a id="my-own-scanner">Свой сканер</a>
[Вернуться к списку заданий](#tasks-list)
1. Реализуйте свой аналог класса Scanner на основе Reader.
2. Примените разработанный Scanner для решения задания «Реверс».
3. При мените разработанный Scanner для решения задания «Статистика слов».
4. Нужно использовать блочное чтение. Код, управляющий чтением, должен быть общим.
5. _Сложный вариант_. Код, выделяющий числа и слова, должен быть общим.
6. Обратите внимание на:
    - Обработку ошибок.
    - На слова/числа, пересекающие границы блоков, особенно — больше одного раза.  

Решение данного задания можно посмотреть [здесь](Scanner.java) в ```Scanner.java```.

<h5>Модификации</h5>

Для класса ```Scanner.java``` тестов нет, он используется в решении некоторых других задач. 

---

### <a id="word-statistics++">Статистика слов++</a>
[Вернуться к списку заданий](#tasks-list)
1. Разработайте класс Wspp, который будет подсчитывать статистику встречаемости слов во входном файле.
2. Словом называется непрерывная последовательность букв, апострофов и тире (Unicode category Punctuation, Dash). Для подсчета статистики, слова приводятся к нижнему регистру.
3. Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления. Для каждого слова должна быть выведена одна строка, содержащая слово, число его вхождений во входной файл и номера вхождений этого слова среди всех слов во входном файле.
4. Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
5. Программа должна работать за линейное от размера входного файла время.
6. Для реализации программы используйте Collections Framework.
7. _Сложный вариант_. Реализуйте и примените класс IntList, компактно хранящий список целых чисел.

Решение данного задания можно посмотреть [здесь](Wspp.java) в ```Wspp.java```.

<h5>Модификации</h5> 

(тесты для задания представлены в [```WsppTest.jar```](FastReverseTest.jar)):
- Position ([решение](WsppPosition.java) представлено в классе ```WsppPosition.java```)
  - Вместо номеров вхождений во всем файле надо указывать ```<номер строки>:<номер в строке>```.
  - Класс должен иметь имя ```WsppPosition```.

---

### Markdown to HTML
[Вернуться к списку заданий](#tasks-list)
1. Разработайте конвертер из Markdown-разметки в HTML.
2. Конвертер должен поддерживать следующие возможности:
    - Абзацы текста разделяются пустыми строками.
    - Элементы строчной разметки: выделение (* или _), сильное выделение (** или __), зачеркивание (--), код (`)
    - Заголовки (# * уровень заголовка)
4. Конвертер должен называться md2html.Md2Html и принимать два аргумента: название входного файла с Markdown-разметкой и название выходного файла c HTML-разметкой. Оба файла должны иметь кодировку UTF-8.
5. При выполнении этого ДЗ можно повторно использовать код ДЗ markup.
6. Конвертер может хранить исходные и сконвертированные данные в памяти, в том числе, одновременно.

Решение данного задания можно посмотреть [здесь](md2html) (решение представлено в двух классах [```md2html/Md2Html.java```](md2html/Md2Html.java) и [```md2html/Methods.java```](md2html/Methods.java)).

Пример:
<table>
    <tr>
        <th>Входной файл</th>
        <th>Выходной файл</th>
    </tr>
    <tr>
        <td><pre>
<code># Заголовок первого уровня</code>
<code></code>
<code>## Второго</code>
<code></code>
<code>### Третьего ## уровня</code>
<code></code>
<code>#### Четвертого</code>
<code># Все еще четвертого</code>
<code></code>
<code>Этот абзац текста,</code>
<code>содержит две строки.</code>
<code></code>
<code>    # Может показаться, что это заголовок.</code>
<code>Но нет, это абзац начинающийся с `#`.</code>
<code></code>
<code>#И это не заголовок.</code>
<code></code>
<code>###### Заголовки могут быть многострочными</code>
<code>(и с пропуском заголовков предыдущих уровней)</code>
<code></code>
<code>Мы все любим *выделять* текст _разными_ способами.</code>
<code>**Сильное выделение**, используется гораздо реже,</code>
<code>но __почему бы и нет__?</code>
<code>Немного --зачеркивания-- еще ни кому не вредило.</code>
<code>Код представляется элементом `code`.</code>
<code></code>
<code>Обратите внимание, как экранируются специальные</code>
<code>HTML-символы, такие как `<`, `>` и `&`.</code>
<code></code>
<code>Знаете ли вы, что в Markdown, одиночные * и _</code>
<code>не означают выделение?</code>
<code>Они так же могут быть заэкранированы</code>
<code>при помощи обратного слэша: \*.</code>
<code></code>
<code></code>
<code>Лишние пустые строки должны игнорироваться.</code>
<code></code>
<code>Любите ли вы *вложеные __выделения__* так,</code>
<code>как __--люблю--__ их я?</code>
        </pre></td>
        <td><pre>
<code>&lt;h1&gt;Заголовок первого уровня&lt;/h1&gt;</code>
<code>&lt;h2&gt;Второго&lt;/h2&gt;</code>
<code>&lt;h3&gt;Третьего ## уровня&lt;/h3&gt;</code>
<code>&lt;h4&gt;Четвертого</code>
<code># Все еще четвертого&lt;/h4&gt;</code>
<code>&lt;p&gt;Этот абзац текста,</code>
<code>содержит две строки.&lt;/p&gt;</code>
<code>&lt;p&gt;    # Может показаться, что это заголовок.</code>
<code>Но нет, это абзац начинающийся с &lt;code&gt;#&lt;/code&gt;.&lt;/p&gt;</code>
<code>&lt;p&gt;#И это не заголовок.&lt;/p&gt;</code>
<code>&lt;h6&gt;Заголовки могут быть многострочными</code>
<code>(и с пропуском заголовков предыдущих уровней)&lt;/h6&gt;</code>
<code>&lt;p&gt;Мы все любим &lt;em&gt;выделять&lt;/em&gt; текст &lt;em&gt;разными&lt;/em&gt; способами.</code>
<code>&lt;strong&gt;Сильное выделение&lt;/strong&gt;, используется гораздо реже,</code>
<code>но &lt;strong&gt;почему бы и нет&lt;/strong&gt;?</code>
<code>Немного &lt;s&gt;зачеркивания&lt;/s&gt; еще ни кому не вредило.</code>
<code>Код представляется элементом &lt;code&gt;code&lt;/code&gt;.&lt;/p&gt;</code>
<code>&lt;p&gt;Обратите внимание, как экранируются специальные</code>
<code>HTML-символы, такие как &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;amp;&lt;/code&gt;.&lt;/p&gt;</code>
<code>&lt;p&gt;Знаете ли вы, что в Markdown, одиночные * и _</code>
<code>не означают выделение?</code>
<code>Они так же могут быть заэкранированы</code>
<code>при помощи обратного слэша: *.&lt;/p&gt;</code>
<code>&lt;p&gt;Лишние пустые строки должны игнорироваться.&lt;/p&gt;</code>
<code>&lt;p&gt;Любите ли вы &lt;em&gt;вложеные &lt;strong&gt;выделения&lt;/strong&gt;&lt;/em&gt; так,</code>
<code>как &lt;strong&gt;&lt;s&gt;люблю&lt;/s&gt;&lt;/strong&gt; их я?&lt;/p&gt;</code>
        </pre></td>
    </tr>
</table>

<h5>Модификации</h5> 

(тесты для данного задания представлены в [```Md2HtmlTest.jar```](md2html/Md2HtmlTest.jar) ):
- Var ([решение](md2html/Methods.java) представлено в классе ```md2html/Methods.java```, как и базовая реализация)
   - Добавьте поддержку ```%переменных%: <var>переменных</var>```.

---

### <a id="mnk-game">Игра m,n,k</a>
[Вернуться к списку заданий](#tasks-list)
1. Реализуйте игру m,n,k (k в ряд на доске m×n).
2. Добавьте обработку ошибок ввода пользователя. В случае ошибочного хода пользователь должен иметь возможность сделать другой ход.
3. Добавьте обработку ошибок игроков. В случае ошибки игрок автоматически проигрывает.
4. Простая версия. Доска может производить обработку хода за O(nmk).
5. _Сложная версия_.
    - Доска должна производить обработку хода (проверку корректности, изменение состояния и определение результата) за O(k).
    - Предотвратите жульничество: у игрока не должно быть возможности достать Board из Position.
6. _Бонусная версия_. Реализуйте Winner — игрок, который выигрывает всегда, когда это возможно (против любого соперника).
7. Код должен находиться в пакете game.

<h5>Модификации</h5> 

(тесты для данного задания отсутствуют):
- Матчи
  - Добавьте поддержку матчей: последовательность игр до указанного числа побед.
  - Стороны в матче должны меняться каждую игру.

---

### <a id="expressions">Выражения</a>
[Вернуться к списку заданий](#tasks-list)
1. Разработайте классы Const, Variable, Add, Subtract, Multiply, Divide для вычисления выражений с одной переменной в типе int (интерфейс Expression).
2. Классы должны позволять составлять выражения вида
<pre>
new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
).evaluate(5)
</pre>
            
При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра методу evaluate. Таким образом, результатом вычисления приведенного примера должно стать число 7.

3. Метод toString должен выдавать запись выражения в полноскобочной форме. Например
<pre>
new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
).toString()
</pre>
            
должен выдавать ((2 * x) - 3).

4. _Сложный вариант_. Метод toMiniString (интерфейс ToMiniString) должен выдавать выражение с минимальным числом скобок. Например
<pre>
new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
).toMiniString()
</pre>
должен выдавать 2 * x - 3.

5. Реализуйте метод equals, проверяющий, что два выражения совпадают. Например,
<pre>
new Multiply(new Const(2), new Variable("x"))
    .equals(new Multiply(new Const(2), new Variable("x")))
</pre>
            
должно выдавать true, а
<pre>
new Multiply(new Const(2), new Variable("x"))
    .equals(new Multiply(new Variable("x"), new Const(2)))
</pre>
            
должно выдавать false.

6. Для тестирования программы должен быть создан класс Main, который вычисляет значение выражения x2−2x+1, для x, заданного в командной строке.
7. При выполнении задания следует обратить внимание на:
    - Выделение общего интерфейса создаваемых классов.
    - Выделение абстрактного базового класса для бинарных операций.

Решение данного задания можно посмотреть [здесь](expression) в ```expression/*.java```.

<h5>Модификации</h5> 

(тесты для данного задания представлены в [```java/expressions/*Expression.java```](java/expression) интерфейсах, примеры тестов для каждой модификации содержатся в соответствующем интерфейсе):
- Triple ([решение](expression) представлено в классах ```expression/*.java```, как и базовая реализация)
   - Добавьте поддержку ```%переменных%: <var>переменных</var>```.

---
